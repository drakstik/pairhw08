Our design for the three views is based strictly on the MVC design pattern. We created controller for each view that performed most of the computation and analysis of data from the model. Each of the three controllers were designed to take a complete model that was updated with the modelBuilder. The controller would then process the data from the model, which was gathered in the form of ArrayLists of "operations". These operations represented the operations that could be done on a shape: add, move, scale, change color. Each controller would process these operations and return the shapes made and created to the appropriate view in the appropriate format. The view would then display the data in the appropriate manor. In the visual view, for example, the view set up a timer, whose ticks triggered an action function in the controller. This action function would process all of the operation data from the model and create maps of shapes and their corresponding colors. The controller would then call a function in the view that accepted these formatted shape and color objects. The view would load these shapes and colors and refresh its display. For this project we updated a fair amount of the code from the model created in the last project. The most important aspect of this change was adding the data structures to hold the operations done on each shape. These structures were not present in our models before, and we therefore we could not access the information about the animation in a more efficient way than calling functions to return the description strings about the animation and then parsing these strings. After adding these data structures to the model we decided to process the data in a controller, rather than giving our view direct access to our model. This greatly simplified the code written for our views, and allowed them to be more adaptable, given that they were separated from the model and not tied to our implementation of that model.